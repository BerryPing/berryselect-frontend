import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import SectionBox from "@/components/common/SectionBox";
import CardItem from "@/components/wallet/CardItem";
import berrylogo from "@/assets/imgs/berrylogo.png";
import { type CardSummary, getCards, getCardBenefits, type CardBenefitsGrouped, type BenefitGroup, type BenefitItem } from "@/api/walletApi";
import styles from "./WalletPage.module.css";
import Button from "@/components/common/Button.tsx";
import { getCardImage, getCardMeta } from "@/components/wallet/CardCatalog.ts";
import { openDeepLink } from "@/utils/deepLink.ts";
import { getUserSettings, type UserSettingsResponse } from "@/api/userApi.ts";
import Modal from "@/components/common/Modal.tsx";
import { Info } from "lucide-react";

/* -------------------- Í≥µÌÜµ UI ÏÖÄ -------------------- */
function BenefitItemRow({ item }: { item: BenefitItem }) {
    const initials =
        item.brand?.trim()?.slice(0, 2).toUpperCase() ??
        (item.title?.trim()?.slice(0, 2).toUpperCase() || "¬∑");

    return (
        <div className={styles.benefitItem}>
            <div className={styles.benefitThumb}>{initials}</div>
            <div className={styles.benefitTexts}>
                <div className={styles.benefitBrand}>{item.brand}</div>
                <div className={styles.benefitTitle}>{item.title}</div>
                {item.subtitle && <div className={styles.benefitSubtle}>{item.subtitle}</div>}
            </div>
        </div>
    );
}

function GroupList({ groups }: { groups: BenefitGroup[] }) {
    if (!groups || groups.length === 0) return null;
    return (
        <div>
            {groups.map((g, i) => (
                <div key={`${g.category}-${i}`} className={styles.groupBlock}>
                    <div className={styles.groupTitle}>{g.category}</div>
                    <div style={{ display: "grid", gap: 12 }}>
                        {g.items.map((it, idx) => (
                            <BenefitItemRow key={idx} item={it} />
                        ))}
                    </div>
                </div>
            ))}
        </div>
    );
}

/* -------------------- Ïπ¥ÌÖåÍ≥†Î¶¨ Ïπ© -------------------- */
const MASTER_CATS = ["Ï†ÑÏ≤¥", "Ïπ¥Ìéò", "Ìé∏ÏùòÏ†ê", "ÍµêÌÜµ", "ÏáºÌïë", "ÏùåÏãù", "Í∏∞ÌÉÄ"] as const;
type MasterCat = (typeof MASTER_CATS)[number];
const catEmoji: Record<string, string> = { Ï†ÑÏ≤¥:"üêæ", Ïπ¥Ìéò:"‚òï", Ìé∏ÏùòÏ†ê:"üè™", ÍµêÌÜµ:"üöó", ÏáºÌïë:"üõí", ÏùåÏãù:"üçΩÔ∏è", Í∏∞ÌÉÄ:"‚ú®" };

const normCat = (s?: string) =>
    (s ?? "").normalize("NFKC").replace(/[^\p{L}\p{N}]+/gu, "").toLowerCase();

const MASTER_NORM_MAP = new Map<string, MasterCat>(
    (MASTER_CATS as readonly string[]).map((c) => [normCat(c), c as MasterCat])
);

/* --------- Helpers --------- */
function computeActiveIndex(container: HTMLDivElement): number {
    const cards = Array.from(container.querySelectorAll<HTMLDivElement>('[data-card-slot="1"]'));
    if (cards.length === 0) return 0;
    const containerRect = container.getBoundingClientRect();
    const containerCenter = containerRect.left + containerRect.width / 2;

    let bestIdx = 0; let bestDist = Number.POSITIVE_INFINITY;
    cards.forEach((el, idx) => {
        const r = el.getBoundingClientRect();
        const center = r.left + r.width / 2;
        const dist = Math.abs(center - containerCenter);
        if (dist < bestDist) { bestDist = dist; bestIdx = idx; }
    });
    return bestIdx;
}

function mergeGroups(groups: BenefitGroup[]): BenefitGroup[] {
    const byKey = new Map<string, BenefitGroup>();
    for (const g of groups) {
        const key = normCat(g.category);
        const ex = byKey.get(key);
        if (!ex) byKey.set(key, { category: g.category, items: [...g.items] });
        else ex.items.push(...g.items);
    }
    return Array.from(byKey.values());
}

/* ================= Ïã§Ï†Å/Íµ¨Í∞Ñ Í≥ÑÏÇ∞ Ïú†Ìã∏ ================= */
type Tier = { label: string; min: number; max: number | null };
type CardSummaryExt = CardSummary & { prevMonthSpend?: number };
type BenefitsExt = CardBenefitsGrouped & { spendTiers?: Tier[]; benefitNoteHtml?: string };

function isTierArray(v: unknown): v is Tier[] {
    return Array.isArray(v) && v.every(
        (t) => t && typeof t === "object" &&
            typeof (t as Tier).label === "string" &&
            typeof (t as Tier).min === "number" &&
            ("max" in (t as Tier))
    );
}
const DEFAULT_TIERS: Tier[] = [
    { label: "0Íµ¨Í∞Ñ", min: 0, max: 200_000 },
    { label: "1Íµ¨Í∞Ñ", min: 200_000, max: 500_000 },
    { label: "2Íµ¨Í∞Ñ", min: 500_000, max: null },
];
function findTier(spend: number, tiers: Tier[]) {
    const idx = tiers.findIndex((t) => (t.max == null ? spend >= t.min : spend >= t.min && spend < t.max));
    return idx >= 0 ? idx : tiers.length - 1;
}
function formatMoney(n: number) { return n.toLocaleString("ko-KR") + "Ïõê"; }

/* =============== Component =============== */
export default function CardSection() {
    const [cards, setCards] = useState<CardSummary[]>([]);
    const [loadingCards, setLoadingCards] = useState(false);
    const [cardsError, setCardsError] = useState<string | null>(null);
    const listRef = useRef<HTMLDivElement>(null);

    const [activeIndex, setActiveIndex] = useState(0);
    const activeCard = cards[activeIndex];

    const [benefits, setBenefits] = useState<CardBenefitsGrouped | null>(null);
    const [loadingBenefits, setLoadingBenefits] = useState(false);
    const [benefitsError, setBenefitsError] = useState<string | null>(null);
    const [activeOther, setActiveOther] = useState<MasterCat>("Ï†ÑÏ≤¥");

    const [settings, setSettings] = useState<UserSettingsResponse | null>(null);
    const [loadingSettings, setLoadingSettings] = useState(false);

    const [openPerfModal, setOpenPerfModal] = useState(false);

    /* 1) Ïπ¥Îìú Î™©Î°ù */
    useEffect(() => {
        let cancelled = false;
        (async () => {
            try {
                setLoadingCards(true); setCardsError(null);
                const list = await getCards();
                if (!cancelled) { setCards(list); setActiveIndex(0); }
            } catch {
                if (!cancelled) setCardsError("Ïπ¥Îìú Î™©Î°ùÏùÑ Î∂àÎü¨Ïò§ÏßÄ Î™ªÌñàÏäµÎãàÎã§.");
            } finally {
                if (!cancelled) setLoadingCards(false);
            }
        })();
        return () => { cancelled = true; };
    }, []);

    /* 2) ÏÇ¨Ïö©Ïûê ÏÑ§Ï†ï */
    useEffect(() => {
        let cancelled = false;
        (async () => {
            try {
                setLoadingSettings(true);
                const s = await getUserSettings();
                if (!cancelled) setSettings(s);
            } catch {
                if (!cancelled) setSettings(null);
            } finally {
                if (!cancelled) setLoadingSettings(false);
            }
        })();
        return () => { cancelled = true; };
    }, []);

    /* 3) ÌòúÌÉù Î°úÎìú */
    useEffect(() => {
        if (!activeCard?.cardId) { setBenefits(null); setActiveOther("Ï†ÑÏ≤¥"); return; }
        let cancelled = false;
        setLoadingBenefits(true); setBenefitsError(null);

        getCardBenefits(activeCard.cardId)
            .then((res) => {
                if (cancelled) return;
                setBenefits(res);

                const merged = mergeGroups([...(res.personalized ?? []), ...(res.others ?? [])]);
                const available = new Set(merged.map((g) => normCat(g.category)));

                let next: MasterCat | undefined;
                for (const c of settings?.preferredCategories ?? []) {
                    const key = normCat(c);
                    if (available.has(key)) {
                        const mapped = MASTER_NORM_MAP.get(key);
                        if (mapped) { next = mapped; break; }
                    }
                }
                setActiveOther(next ?? "Ï†ÑÏ≤¥");
            })
            .catch((e: unknown) => {
                if (cancelled) return;
                const msg = e instanceof Error ? e.message : "ÌòúÌÉùÏùÑ Î∂àÎü¨Ïò§ÏßÄ Î™ªÌñàÏäµÎãàÎã§.";
                setBenefitsError(msg);
            })
            .finally(() => { if (!cancelled) setLoadingBenefits(false); });

        return () => { cancelled = true; };
    }, [activeCard?.cardId, settings?.preferredCategories]);

    /* 4) Í∞ÄÎ°ú Ïä§ÌÅ¨Î°§ ÌôúÏÑ± Ïπ¥Îìú Ï∂îÏ†Å */
    const rafRef = useRef<number | null>(null);
    const onScroll = useCallback(() => {
        if (!listRef.current) return;
        if (rafRef.current) cancelAnimationFrame(rafRef.current);
        rafRef.current = requestAnimationFrame(() => {
            if (!listRef.current) return;
            const idx = computeActiveIndex(listRef.current);
            setActiveIndex((prev) => (prev === idx ? prev : idx));
        });
    }, []);
    useEffect(() => {
        const el = listRef.current; if (!el) return;
        el.addEventListener("scroll", onScroll, { passive: true });
        return () => el.removeEventListener("scroll", onScroll);
    }, [onScroll]);
    useEffect(() => {
        if (!listRef.current || cards.length === 0) return;
        setActiveIndex(computeActiveIndex(listRef.current));
    }, [cards.length]);

    const cardDisplayName = (c: CardSummary): string => {
        if (c.name) return c.name;
        const issuer = c.issuer ?? "Ïπ¥Îìú";
        const last4 = c.last4 ? ` ‚Ä¢‚Ä¢‚Ä¢‚Ä¢ ${c.last4}` : "";
        return `${issuer}${last4}`;
    };

    const handleSelectCard = (cardId?: number) => {
        if (!cardId || !listRef.current) return;
        const idx = cards.findIndex((c) => c.cardId === cardId);
        if (idx < 0) return; setActiveIndex(idx);

        const container = listRef.current;
        const slots = container.querySelectorAll<HTMLDivElement>('[data-card-slot="1"]');
        const target = slots[idx]; if (!target) return;

        const containerRect = container.getBoundingClientRect();
        const targetRect = target.getBoundingClientRect();
        const containerCenter = container.scrollLeft + container.clientWidth / 2;
        const targetCenter = container.scrollLeft + (targetRect.left - containerRect.left) + targetRect.width / 2;

        container.scrollTo({ left: container.scrollLeft + (targetCenter - containerCenter), behavior: "smooth" });
    };

    /* -------- ‚ÄúÍ∑∏ Ïô∏ ÌòúÌÉù‚Äù = ÎßûÏ∂§Ìòï + Í∑∏Ïô∏ Ï†ÑÏ≤¥ ------- */
    const allGroups = useMemo<BenefitGroup[]>(() => {
        const p = benefits?.personalized ?? []; const o = benefits?.others ?? [];
        return mergeGroups([...p, ...o]);
    }, [benefits]);

    const groupsByCat = useMemo(() => {
        const m = new Map<string, BenefitGroup>(); for (const g of allGroups) m.set(normCat(g.category), g); return m;
    }, [allGroups]);

    const mergedAll = useMemo<BenefitGroup>(() => ({ category: "Ï†ÑÏ≤¥", items: allGroups.flatMap((g) => g.items) }), [allGroups]);

    const selectedGroup: BenefitGroup = useMemo(() => {
        if (activeOther === "Ï†ÑÏ≤¥") return mergedAll;
        return groupsByCat.get(normCat(activeOther)) ?? { category: activeOther, items: [] };
    }, [activeOther, mergedAll, groupsByCat]);

    /* =============== Ï¥ù Ïã§Ï†Å/Íµ¨Í∞Ñ(Î™®Îã¨) =============== */
    const thisMonthSpend = Math.max(0, Number(activeCard?.thisMonthSpend ?? 420_000)); // ÏòàÏãú Í∏∞Î≥∏Í∞í
    const prevMonthSpend = Math.max(0, Number((activeCard as CardSummaryExt)?.prevMonthSpend ?? 380_000)); // ÏòàÏãú Í∏∞Î≥∏Í∞í

    const tiersFromApi = (benefits as BenefitsExt | null)?.spendTiers;
    const TIERS: Tier[] = isTierArray(tiersFromApi) && tiersFromApi.length > 0 ? tiersFromApi : DEFAULT_TIERS;
    const tierIdx = findTier(prevMonthSpend, TIERS);
    const currTier = TIERS[tierIdx];
    const nextTier = TIERS[tierIdx + 1];
    const needToNext = nextTier?.min != null ? Math.max(0, nextTier.min - prevMonthSpend) : 0;

    const meterMax = currTier?.max ?? 1_000_000;
    const meterPct = Math.min(100, (thisMonthSpend / meterMax) * 100);

    const barRatio = (() => {
        if (!currTier) return 0;
        if (currTier.max == null) return 1;
        const span = currTier.max - currTier.min;
        const pos = Math.min(currTier.max, Math.max(currTier.min, prevMonthSpend)) - currTier.min;
        return Math.max(0, Math.min(1, pos / span));
    })();

    return (
        <>
            <SectionBox width={352} padding="0px 16px 23px" outlined shadow={false}>
                <div className={styles.sectionTitleCompact}>
                    <br />
                    {activeCard && <span className={styles.activeCardName}>&nbsp;{activeCard.name}</span>}
                </div>

                {loadingCards && <div className={styles.loading}>Î∂àÎü¨Ïò§Îäî Ï§ë‚Ä¶</div>}
                {cardsError && !loadingCards && <div className={styles.error}>{cardsError}</div>}
                {!loadingCards && !cardsError && cards.length === 0 && (
                    <div className={styles.empty}>Î≥¥Ïú† Ïπ¥ÎìúÍ∞Ä ÏóÜÏäµÎãàÎã§.</div>
                )}

                {!loadingCards && !cardsError && cards.length > 0 && (
                    <div
                        ref={listRef}
                        aria-label="Î≥¥Ïú† Ïπ¥Îìú Î™©Î°ù"
                        className={styles.hList}
                        onScroll={onScroll}
                        onTouchMove={onScroll}
                        onWheel={onScroll}
                    >
                        {cards.map((c) => (
                            <div key={c.cardId} data-card-slot="1" className={styles.cardSlot}>
                                <div className={styles.cardSlotInner}>
                                    <CardItem
                                        cardId={c.cardId}
                                        name={cardDisplayName(c)}
                                        imageUrl={getCardImage(c.name)}
                                        onClick={handleSelectCard}
                                        onOpenApp={() => openDeepLink(getCardMeta(c.name)?.deepLink)}
                                    />
                                </div>
                            </div>
                        ))}
                    </div>
                )}
            </SectionBox>

            {/* Î≤†Î¶¨ÌîΩ Î≤ÑÌäº */}
            <div className={styles.actionBtnWrap}>
                <Button className={styles.sectionLikeBtn} onClick={() => {}}>
          <span className={styles.btnInner}>
            <img src={berrylogo} alt="Î≤†Î¶¨Î°úÍ≥†" className={styles.berryselectLogo} />
            <span className={styles.btnText}>Î≤†Î¶¨ÌîΩ Í≤∞Ï†ú Ï∂îÏ≤ú Î∞õÍ∏∞</span>
          </span>
                </Button>
            </div>

            {/* Ïù¥Î≤à Îã¨ ÌòÑÌô© */}
            <SectionBox width={352} padding="16px" outlined shadow={false}>
                <div className={styles.statusCardWrap}>
                    <div className={styles.statusTitle}>Ïù¥Î≤à Îã¨ ÌòÑÌô©</div>
                    <div className={styles.statusRow}>
                        {/* Ï¥ù Ïã§Ï†Å */}
                        <div className={styles.statusCard}>
                            <div className={styles.statusHeader}>
                                <div className={styles.statusLabel}>Ï¥ù Ïã§Ï†Å</div>
                                <Info
                                    type="button"
                                    className={styles.infoBtn}
                                    aria-label="Ïã§Ï†Å ÏÉÅÏÑ∏ Î≥¥Í∏∞"
                                    onClick={() => setOpenPerfModal(true)}
                                >
                                </Info>
                            </div>
                            <div className={styles.statusValue}>
                                {Math.floor(thisMonthSpend / 10_000)}/{Math.floor(meterMax / 10_000)}ÎßåÏõê
                            </div>
                            <div className={styles.statusMeter}>
                                <div className={styles.statusMeterFill} style={{ width: `${meterPct}%` }} />
                            </div>
                        </div>

                        {/* ÏûîÏó¨ ÏòàÏÇ∞ */}
                        <div className={styles.budgetCard}>
                            <div className={styles.budgetLabel}>ÏûîÏó¨ ÏòàÏÇ∞</div>
                            <div className={styles.budgetValue}>120,000Ïõê</div>
                            <div className={styles.budgetMeter}>
                                <div className={styles.budgetMeterFill} style={{ width: "62%" }} />
                            </div>
                        </div>
                    </div>
                </div>
            </SectionBox>

            {/* ÎßûÏ∂§Ìòï ÌòúÌÉù */}
            <SectionBox width={352} padding="16px" outlined shadow={false}>
                <div className={styles.benefitsBox}>
                    <div className={styles.sectionTitle}>ÎßûÏ∂§Ìòï ÌòúÌÉù</div>

                    {loadingSettings && <div className={styles.loading}>Í∞úÏù∏Ìôî ÏÑ§Ï†ï Î∂àÎü¨Ïò§Îäî Ï§ë‚Ä¶</div>}
                    {loadingBenefits && <div className={styles.loading}>ÌòúÌÉù Î∂àÎü¨Ïò§Îäî Ï§ë‚Ä¶</div>}
                    {benefitsError && !loadingBenefits && <div className={styles.error}>{benefitsError}</div>}

                    {!loadingBenefits && !benefitsError && (
                        <>
                            {/* ‚ë† ÎßûÏ∂§Ìòï */}
                            {(() => {
                                const p = benefits?.personalized ?? [];
                                if (p.length === 0) {
                                    return (
                                        <div className={styles.empty}>
                                            {(settings?.preferredCategories?.length ?? 0) === 0
                                                ? "ÌöåÏõêÍ∞ÄÏûÖ Ïãú ÏÑ†Ìò∏ Ïπ¥ÌÖåÍ≥†Î¶¨Î•º ÏïÑÏßÅ ÏÑ†ÌÉùÌïòÏßÄ ÏïäÏïòÏñ¥Ïöî. (0~3Í∞ú ÏÑ†ÌÉù Í∞ÄÎä•)"
                                                : "ÏÑ†Ìò∏ Ïπ¥ÌÖåÍ≥†Î¶¨Ïóê Ìï¥ÎãπÌïòÎäî Ïπ¥Îìú ÌòúÌÉùÏù¥ ÏïÑÏßÅ ÏóÜÏñ¥Ïöî. Îã§Î•∏ Ïπ¥ÌÖåÍ≥†Î¶¨ÎèÑ ÌôïÏù∏Ìï¥ Î≥¥ÏÑ∏Ïöî."}
                                        </div>
                                    );
                                }
                                return <GroupList groups={p} />;
                            })()}

                            {/* ‚ë° Í∑∏ Ïô∏ ÌòúÌÉù */}
                            <div style={{ marginTop: 16 }}>
                                <div className={styles.subSectionTitle}>Í∑∏ Ïô∏ ÌòúÌÉù</div>
                                <div className={styles.chipsRow}>
                                    {MASTER_CATS.map((cat) => {
                                        const selected = cat === activeOther;
                                        return (
                                            <button
                                                key={cat}
                                                type="button"
                                                className={[styles.chip, selected ? styles.chipSelected : ""].join(" ")}
                                                onClick={() => setActiveOther(cat)}
                                                aria-pressed={selected}
                                                title={catEmoji[cat] + " " + cat}
                                            >
                                                {cat}
                                            </button>
                                        );
                                    })}
                                </div>

                                {selectedGroup.items.length > 0 ? (
                                    <div className={styles.groupBlock}>
                                        <div className={styles.groupTitle}>{selectedGroup.category}</div>
                                        <div style={{ display: "grid", gap: 12 }}>
                                            {selectedGroup.items.map((it, idx) => (
                                                <BenefitItemRow key={idx} item={it} />
                                            ))}
                                        </div>
                                    </div>
                                ) : (
                                    <div className={styles.empty}>ÌëúÏãúÌï† ÌòúÌÉùÏù¥ ÏóÜÏñ¥Ïöî.</div>
                                )}
                            </div>
                        </>
                    )}
                </div>
            </SectionBox>

            {/* ===== Ïã§Ï†Å Î™®Îã¨ ===== */}
            <Modal open={openPerfModal} onClose={() => setOpenPerfModal(false)}>
                <div className={styles.modalSheet}>
                    {/* ÏÉÅÎã® Ìï∏Îì§ + ÌÉÄÏù¥ÌãÄ */}
                    <div className={styles.modalHandle} />
                    <div className={styles.modalHeader}>
                        <div className={styles.modalTitle}>Ïπ¥Îìú Ïù¥Ïö©Ïã§Ï†Å ¬∑ ÌòúÌÉù</div>
                    </div>

                    {/* [A] Ïã§Ï†Å Ïù∏Ï†ïÍ∏àÏï° ÌÉÄÏù¥ÌãÄ */}
                    <div className={styles.progressTitle}>Ïã§Ï†Å Ïù∏Ï†ïÍ∏àÏï°</div>

                    {/* [B] ÏÉÅÎã® ÏßÑÌñâÎ∞î */}
                    <div className={styles.tierProgressWrap}>
                        <div className={styles.tierProgressRail}>
                            <div
                                className={styles.tierProgressFill}
                                style={{ width: `${barRatio * 100}%` }}
                            />
                        </div>
                        <div className={styles.tierLabels}>
                            <span>0Íµ¨Í∞Ñ</span>
                            <span>1Íµ¨Í∞Ñ</span>
                            <span>2Íµ¨Í∞Ñ</span>
                        </div>
                    </div>

                    {/* [C] Îã§Ïùå Íµ¨Í∞Ñ Î∞ïÏä§ */}
                    <div className={styles.nextBox}>
                        <div className={styles.nextInline}>
                            <span className={styles.nextPrefix}>Îã§Ïùå Íµ¨Í∞Ñ ÍπåÏßÄ</span>
                            <strong className={styles.nextAmount}>{formatMoney(needToNext)}</strong>
                            <span className={styles.nextSuffix}>ÎÇ®ÏïòÏñ¥Ïöî</span>
                        </div>
                    </div>

                    {/* [D] ÏÑπÏÖò Ï†úÎ™©: Íµ¨Í∞ÑÎ≥Ñ ÌòúÌÉù ÎÇ¥Ïö© */}
                    <div className={styles.subSectionHeader}>Íµ¨Í∞ÑÎ≥Ñ ÌòúÌÉù ÎÇ¥Ïö©</div>

                    {/* [E] Íµ¨Í∞Ñ Pill */}
                    <div className={styles.tierPills}>
                        {TIERS.map((t, i) => {
                            const selected = i === tierIdx;
                            return (
                                <button
                                    key={t.label}
                                    type="button"
                                    className={[styles.tierPill, selected ? styles.tierPillActive : ""].join(" ")}
                                >
                                    {t.label.replace("Íµ¨Í∞Ñ", "")}
                                </button>
                            );
                        })}
                    </div>

                    {/* [F] ÌòúÌÉù ÏÑ§Î™Ö Î™©Î°ù */}
                    <div className={styles.benefitBullets}>
                        <div className={styles.bullet}>
                            ÌòúÌÉù Ï°∞Í±¥: Ï†ÑÏõî Ïã§Ï†Å {currTier.min.toLocaleString()}Ïõê Ïù¥ÏÉÅ ~{" "}
                            {currTier.max ? `${currTier.max.toLocaleString()}Ïõê ÎØ∏Îßå` : "ÏÉÅÌïú ÏóÜÏùå"}
                        </div>
                        <div className={styles.bullet}>Ïπ¥Ìéò¬∑Ìé∏ÏùòÏ†ê 5% Ìï†Ïù∏</div>
                        <div className={styles.bullet}>Ïò®ÎùºÏù∏ ÏáºÌïë 2% Ï†ÅÎ¶Ω</div>
                        <div className={styles.bullet}>
                            {nextTier
                                ? `${nextTier.min.toLocaleString()}Ïõê Ïù¥ÏÉÅ ÏÇ¨Ïö© Ïãú ${nextTier.label} ÌòúÌÉùÏù¥ Ïó¥Î†§Ïöî`
                                : "ÏµúÍ≥† Íµ¨Í∞ÑÏûÖÎãàÎã§!"}
                        </div>
                    </div>
                </div>
            </Modal>
        </>
    );
}